# Условие задачи
#
# Ограничение времени, с	1
# Ограничение памяти, МБ	64
# Общее число попыток отправки	15
#
# Вы очнулись в определённой ячейке (x1,y1) лабиринта, с его картой в руке. Карта показывает, что лабиринт
# представляет собой окружённый сплошной стеной прямоугольник размерами N на M, состоящий из ячеек, каждая
# ячейка самого лабиринта – это проход 0 или стена 1. Перемещаться по лабиринту можно по горизонтали (меняя
# координату x) либо по вертикали (меняя координату y) на одну ячейку, перемещаться по диагонали (меняя за
# один шаг обе координаты) нельзя.
#
# На карте отмечен выход, и он находится в ячейке с координатами (x2,y2).
#
# Ваша задача – найти длину кратчайшего пути из ячейки пробуждения в ячейку выхода. В случае, если такого
# пути нет – нужно вывести 0
#
#
# Входные данные (поступают в стандартный поток ввода)
# Первая строка - целые числа N и M через пробел (2≤N≤500, 2≤M≤500)
#
# Вторая строка – целые числа x1 и y1 через пробел (0≤x1≤499, 0≤y1≤499) – координаты точки пробуждения
#
# Третья строка – целые числа x2 и y2 через пробел (0≤x1≤499, 0≤y1≤499) – координаты точки выхода
#
# Далее N строк, на каждой из которых M чисел 0 или 1 через пробел
#
# Нумерации осей в передаваемых значениях следуют слева направо для X и с первой полученной строки до последней для Y.
# По координатам (x1,y1) и (x2,y2) всегда будут проходы. Координаты точки входа и выхода не совпадают.
#
# Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
#
#
# Выходные данные (ожидаются в стандартном потоке вывода)
# Одно целое число, длина кратчайшего пути из точки (x1,y1) в точку (x2,y2), или 0,
# если из одной точки нельзя попасть в другую
#
#
# Пример 1
#
# Ввод:
# 2 3
# 0 0
# 2 1
# 0 0 0
# 0 0 0
#
# Вывод:
# 3
#
# Пример без стен для понимания структуры входных данных
#
# Пример 2
#
# Ввод:
# 3 3
# 0 0
# 2 0
# 0 1 0
# 0 1 0
# 0 0 0
#
# Вывод:
# 6
#
# Придётся обойти стену
#
# Пример 3
#
# Ввод:
# 3 3
# 0 0
# 2 0
# 0 1 0
# 0 1 0
# 0 1 0
#
# Вывод:
# 0
#
# А здесь обойти не получится, выход недостижим

# РЕШЕНИЕ
from collections import deque


def labyrinth(a: list, start: tuple, end: tuple) -> int:
    """Задача 'Лабиринт'"""
    n = len(a)
    m = len(a[0])

    # вправо, вниз, влево, вверх
    move = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited = [[False] * m for _ in range(n)]
    route = deque([(start, 0)])

    while route:
        (i, j), steps = route.popleft()
        if (i, j) == end:
            return steps

        for di, dj in move:
            ni, nj = i + di, j + dj

            if 0 <= ni < n and 0 <= nj < m and not visited[ni][nj] and a[ni][nj] == 0:
                visited[ni][nj] = True
                route.append(((ni, nj), steps + 1))
    return 0


# Получение данных
n, m = map(int, input().split())
y1, x1 = map(int, input().split())
y2, x2 = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]

# Отдача данных
print(labyrinth(a, (x1, y1), (x2, y2)))
